
% previous section: ./introduction.tex

% 章の構成
この章では, 提案言語である \lamlfcirc について説明する.
はじめに, 言語の文法と型システムを導入し,
簡約関係について説明する.
次に, 同値性の定義を, 簡約関係を踏まえながら紹介する.
最後に, 同値型に関する規則について, 例を交えながら解説する.

\subsection{\lamlfcirc の文法}\label{subsec_syntax}

\begin{fig}{体系の文法}
    \centering
    \begin{align*}
      \textrm{項} && t & ::=
      x \pipe \mylam{x}{T}{t} \pipe
      t \mysp t \pipe \mynext{t} \pipe \myprev{t} \pipe
      \myid{t} \pipe \myidpeel{t}{x}{t} \\
      \textrm{型} && T & ::=
       X \pipe \textrm{Eq}_{T} \pipe
       \Pi x \COL T.T \pipe T\mysp t \pipe {\bigcirc}T\\
       \textrm{カインド} && K & ::=
       * \pipe \Pi x \COL T. K\\
       \textrm{値} && v^{i} & ::= &(i \in \mathbb{N})\\
       && &\pipe \mylam{x}{T}{t} &(i = 0)\\
       && &\pipe \mylam{x}{T}{v_{i}} &(i > 0)\\
       && &\pipe v^{i} \mysp v^{i} &(i > 0)\\
       && &\pipe \mynext{v^{i+1}}\\
       && &\pipe \myprev{v^{i-1}} &(i > 1)\\
       && &\pipe \myid{v^{i}}\\
       && &\pipe \myidpeel{v^{i}}{x}{v^{i}} &(i > 0)\\
      \textrm{環境} && \Gamma & ::=
      \bullet \pipe \Gamma, x \mysncln{n} T
      \pipe \Gamma, X\mydbcln{n} K &(n \in \mathbb{N})
    \end{align*}
    \label{fig_syntax}
\end{fig}

\begin{fig}{判断}
  \centering
  \begin{align*}
    \textrm{適格な環境} && &\vdash \Gamma\\
    \textrm{適格なカインド} && \Gamma &\myvdash{n} K\\
    \textrm{カインド判断} && \Gamma &\myvdash{n} T \DCOL K\\
    \textrm{型判断} && \Gamma &\myvdash{n} t \COL T\\
    \textrm{カインド同値判断} && \Gamma &\myvdash{n} K_1 \myequiv{m} K_2\\
    \textrm{型同値判断} && \Gamma &\myvdash{n} T_1 \myequiv{m} T_2\\
    \textrm{項同値判断} && \Gamma &\myvdash{n} t_1 \myequiv{m} t_2\\
    && &\text{※} n \in \mathbb{N}
  \end{align*}
  \vspace{-10pt}
  \label{fig_judgements}
\end{fig}

\Cref{fig_syntax} は, \lamlfcirc の文法規則を示している.

% 項
項は, 変数, ラムダ抽象, ラムダ適用, 多段階計算に関する \mynext{t} と \myprev{t}
及び 同値型に関する \myid{t} と \myidpeel{t}{x}{t} がある.

\mynext{t} は, 項$t$ のステージを1つ上げて, $t$ というコードを表す.
また, \myprev{t} は, コードである項$t$ のステージを1つ下げて, 通常の項に戻す操作で, 
\tnext の逆演算である.
\myid{t} は, 同値型を構成するための演算子であり, 同値型を持つ項は, 
このあと示される簡約によって正規形をとれば, この形しか存在しない.
\myidpeel{t_{eq}}{x}{t} は, 2つの項の間の同値型から, 別の型を作成するために用いられる項である.
使用の具体例は, \Cref{subsec_equalitytype} において示される.

% 型
型には, 依存型における型族$X$と, 同値型$\textrm{Eq}_{T}$,
型抽象$\Pi x \COL T. T$, 内部に項を持つ依存型 $T \mysp t$,
及び, 多段階計算のプログラムコードを表す$\bigcirc T$がある.
また, 型抽象$\Pi x \COL T_1. T_2$ の $T_2$ の内部に $x$ が束縛変数として出現しない場合は,
単純型付きラムダ計算における関数型と同じように, 束縛変数の $x$ を省いて $T_1 \rarrow T_2$ と表記することがある.

型族$X$ は, \Cref{sec_introduction} における例で言うところの \textrm{Vector} のように, 項を受け取るような型を表している.
また, 型抽象は, ラムダ抽象を持つ項に対して型付けされ, ラムダ抽象の項が受け取った別の項を, 型も受け取ることができることを示している.
${\bigcirc}T$の形のコード型は, この型を持つ項に \tprev を適用すると型$T$ の項となることを示してる.

環境は, 項変数に対するあるステージでの型の束縛及び,型に対するカインドの束縛の集合であり,
両者とも束縛されたステージを保持している. これらの束縛は, 束縛されたのと同じステージでしか用いることができない.


\subsection{型システム}\label{subsec_typesystem}

\begin{fig}{代入の定義}
  \begin{align*}
    &[x \mapsto t]\Pi y \COL T.K &&= \Pi y \COL ([x \mapsto t] T. [x \mapsto t]K\\
    &[x \mapsto t] * &&= *\\
    &[x \mapsto t] X &&= X\\
    &[x \mapsto t] \textrm{Eq}_{T} &&= \textrm{Eq}_{[x \mapsto t] T}\\
    &[x \mapsto t] (\Pi y \COL T_1. T_2) &&= \Pi y \COL [x \mapsto t] T_1. [x \mapsto t] T_2\\
    &[x \mapsto t] (T \mysp t') &&= ([x \mapsto t] T) \mysp ([x \mapsto t] t')\\
    &[x \mapsto t] {\bigcirc}T &&= \bigcirc ([x \mapsto t] T)
  \end{align*}
  \label{fig_def_substitution}
\end{fig}

\begin{fig}{適格性規則}
  \centering
  \footnotesize
  \WFStar \bcpnl
  \WFPi \bcpnl
  % \WFEmpty \bcpnl
  % \WFTm \quad
  % \WFTy
\end{fig}

\begin{fig}{型付け規則}
  \centering
  \footnotesize
  \TVar
  \TAbs \bcpnl
  \TApp
  \TConv \bcpnl
  \TPrevIntro
  \TNextIntro \bcpnl
  \TEqIntro \bcpnl
  \TEqElim
  \label{fig_typing}
\end{fig}

\begin{fig}{カインド付け規則}
  \centering
  \footnotesize
  \KVar \quad
  \KPi \bcpnl
  \KApp \quad
  \KConv \bcpnl
  \KEquiv \quad
  \KCirc
  \label{fig_kinding}
\end{fig}

% == 型付け規則について ==
\Cref{fig_typing}は, 型付け規則を示しており, 
多段階計算に関する規則である\fauxsc{T-PrevIntro}, \fauxsc{T-NextIntro}
及び同値型に関する規則\fauxsc{T-EqIntro} と \fauxsc{T-EqElim} を備えている.
また, \fauxsc{T-Conv} は, 依存型を含む体系に特徴的な規則であり,
内部に同値な項を持つ依存型同士であれば, 型を付け替えても良いことを示している.
% == カインド化規則について ==
\Cref{fig_kinding}は, 型に対するカインド付け規則 を示している. 
\fauxsc{K-Conv}もまた, 依存型に特徴的な規則であり, 
2つの等しいカインドがあった場合, カインドを付け替えることができることを表している.
これは, 間接的に, \fauxsc{T-Conv} と合わせて, カインド内部の型内部の項を,
等しい別の項と入れ替える事ができることを示している.


% == 同値型について == %
% \FB
\subsubsection{同値型について}\label{subsec_equalitytype}

% 同値型は一般的な形をしており, Martin-Löf によって提案された形 \cite{Lof1984} をほとんどそのまま使用している.

% 同値型の規則に関する説明
同値型に関する規則は, \Cref{fig_typing} に示される導入規則 \fauxsc{Eq-Intro} と 除去規則 \fauxsc{Eq-Elim} からなる.
\fauxsc{T-EqIntro}は, 任意の項について, 反射律が成立していることを示している.
\fauxsc{T-EqElim}は, 除去規則であり, 2つの同じ型$T$をもつ項$a, b$ と, その2つの項に関する同値型を持つ項があった場合, 
型$T$を持つ変数$x$が存在する環境において, 型$C(x, x, id(x))$ を持つ項$t$が存在するなら, 
型$C(a, b, \myid{a, b})$ を持つ項を導くことができることを示している.

% 同値型の推移律の証明
この2つの規則のみで. 同値型は反射, 対称, 推移律を満たしていることが確認できる. ここでは, 反射, 対称律は容易に確認できるため,
推移律についてのみ示す.

\Cref{fig_proof_equality_transitive} において, $z_1\COL \myeq{T}{a}{b}$ と $z_2\COL \myeq{T}{b}{c}$ があったとき,\\
${\Gamma \myvdash{n} (\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}) z_2 \COL \myeq{T}{a}{c}}$ が導出できることを示している.

\begin{figure}[htbp]
  \begin{scprooftree}{0.8}
      \AxiomC{$\Gamma \myvdash{n} a\COL T$}
      \AxiomC{$\Gamma \myvdash{n} b\COL T$}
      \AxiomC{$\Gamma \myvdash{n} z_1\COL \myeq{T}{a}{b}$}
      \noLine
      \TrinaryInfC{$\Gamma, x\mysncln{n}T, y\mysncln{n}T, p\mysncln{n}\myeq{T}{x}{y} \myvdash{n} \myeq{T}{y}{u} \rightarrow \myeq{T}{x}{u} \DCOL *$}
      \noLine
      \UnaryInfC{$\Gamma, x\COL T \myvdash{n} \mylam{m}{\myeq{T}{x}{c}}{m}\COL \myeq{T}{x}{c} \rightarrow \myeq{T}{x}{c}$}
      \singleLine
      \myplabel{Eq-Elim}
      \UnaryInfC{$\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}\COL \myeq{T}{b}{c} \rightarrow \myeq{T}{a}{c}$}
      \AxiomC{$\Gamma \myvdash{n} z_2\COL \myeq{T}{b}{c}$}
      \myplabel{T-App}
      \BinaryInfC{$\Gamma \myvdash{n} (\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}) z_2 \COL \myeq{T}{a}{c}$}
  \end{scprooftree}
  \label{fig_proof_equality_transitive}
  \caption{同値型における推移律の証明}
\end{figure}

% 同値から同値型の証明
また, 同値型は体系の同値に強く関係する. 2つの項が体系で同値であれば, それに対応する同値型を導き出す事ができる. 
逆に, 2つの項が同値でなければ, それらの同値型を導き出す事はできない.

\Cref{fig_equality_equiv} は, ともに型$T$を持つ項 $t_1$ と$t_2$ と, ${\Gamma \myvdash{n} t_1 \myequiv{m} t_2}$
から, 型 $\myeq{T}{t_1}{t_2}$ となる項を導くことで, 同値な2つの項からは同値型を導けることを示している.

\begin{figure}[htbp]
  \begin{scprooftree}{0.7}
    \AxiomC{$\Gamma \vdash t_1 \COL T$}
    \myplabel{Eq-Intro}
    \UnaryInfC{$\Gamma \vdash id(t_1) \COL \myeq{T}{t_1}{t_2}(t_1, t_1)$}
    \AxiomC{$\Gamma \vdash Eq_T t_1 \DCOL \Pi y\COL T. *$}
    \myplabel{QT-Refl}
    \UnaryInfC{$\Gamma \vdash Eq_T t_1 \equiv Eq_T t_1 \DCOL \Pi y\COL T. *$}
    \AxiomC{$\Gamma \vdash t_1 \equiv t_2$}
    \myplabel{QT-App}
    \BinaryInfC{$\Gamma \vdash Eq_T(t_1, t_1) \equiv \myeq{T}{t_1}{t_2}$}
    \myplabel{T-Conv}
    \BinaryInfC{$\Gamma \vdash id(t_1) \COL \myeq{T}{t_1}{t_2}$}
  \end{scprooftree}
  \caption{同値性から対応する同値型の導出}
  \label{fig_equality_equiv}
\end{figure}


\FB
\subsubsection{体系の同値}

\Cref{subsec_reduction} で示される通り, 多段階計算においては,
\tnext で表されるコード中では一部の簡約を適用したくないなどの理由から,
簡約関係を自然数に関して拡張する.

項の同値も, この簡約によって等しくなる項同士に対して定義したいため,
同様に自然数に関して拡張する. 説明の都合上, 項の簡約の定義を踏まえて
同値性の導入を行いたいため, 体系の同値性についてはここでは述べず, 
\Cref{subsec_equiv} で述べる.

\FB
\subsection{項の簡約}\label{subsec_reduction}
項の簡約規則については, \Cref{fig_reduction} に示されるとおりである.
簡約関係は, Yuse ら\cite{Yuse}を参考に, 整数インデックスに関して拡張されている.
簡約は4種類あり, \mbeta-簡約, ステージに関する2種類の簡約, 及び同値型に関する簡約からなる.
% ベータ簡約
\mbeta-簡約と同値型に関する簡約は, プログラムコードの内部の項に対しては, 適用したくない.
このような定義を可能にするため, ステージ0の項, 即ちプログラムコードでない通常の項に対してのみ
簡約が行えるように, 規則にはインデックスの制限がついている.
% ステージに関する簡約について
ステージに関する簡約は, \fauxsc{E-StageBeta}と\fauxsc{E-StageEta} からなり, 
\fauxsc{E-StageBeta} は, \tnext でステージが一つ上がった項に対して, \tprev を適用することにより, 
再びもとのステージに戻ることに対応する. 
\fauxsc{E-StageEta} は, \tprev で1つ前のステージに引き戻されたプログラムコードが, 
\tnext によって, もとのステージに戻ることを表現している.
% ステージに関する簡約の制限
このうち, \fauxsc{E-StageBeta} は, コード内部への他のコードの埋め込みに用いられる.
よって, 一重のプログラムコード内では, \fauxsc{E-StageBeta} の簡約を許すため,
ステージが1までの項において, この簡約は許されている.
% 項の簡約と値
このように, 項の簡約は, インデックスによって適用可能な規則が変わり, 
それに応じて値の定義も, 簡約のインデックスによって変化する.
このため, \Cref{fig_syntax} において, 値もインデックスによって拡張された形で定義されており,
$v^{i}$ は, $i$-インデックスの簡約がこれ以上存在しない項を表している.

\begin{fig}{簡約規則}
  \centering
  \footnotesize
  \EAppAbs \bcpnl
  \EAbs \bcpnl
  \EAppOne \quad
  \EAppTwo \bcpnl
  \EStageBeta \bcpnl
  \EStageEta \bcpnl
  \ENext \quad
  \EPrev \bcpnl
  \EId \quad
  \EIdpeel \bcpnl
  \EEq
  \label{fig_reduction}
\end{fig}


\subsection{同値性の定義}\label{subsec_equiv}
同値は, カインド, 型, 項のすべてに対して自然数インデックスにより定義を拡張され, インデックスを含む記号 $\myequiv{m}$ で表される.
インデックスによって, 簡約規則を制限することで, 簡約関係に対応するような同値性の定義を可能にしており,
インデックスは, 簡約における場合と同様, 対象の項のステージを表している.

\subsubsection{項に関する同値性}
\Cref{fig_q} は, 項に関する同値規則を表している.

% 同値規則の index がどのように変化していくか
はじめに, 項の同値の評価規則のうち, インデックスの値を変化させる規則は, 
\fauxsc{Q-NextIntro} と \fauxsc{Q-PrevIntro} である. この規則では, 
\tnext の内部の項は インデックスをインクリメントした同値で比較し, 
\tprev の内部は, インデックスをデクリメントした同値で比較することで, 
インデックスをステージに対応させていることがわかる.

次に注目するべきは, コード間の同値である.
% StageBeta
例えば, プログラムコードの内部では, コードの埋め込みに対応する
\fauxsc{E-StageBeta} の簡約しか許されていないことに注意すると,
このような同値を判断する際には, コードの埋め込みを通じて
等しくなるような項同士のみを同値と定義したい.
実際, \fauxsc{Q-StageBeta} では, \Cref{ex_03} のように, インデックスが1以下,
即ち高々一重のコード内部のみ, この規則の適用が許されている事がわかる.
% 続き... (成立しない場合)
対して, \Cref{ex_04} のように, 2重の \tnext 内部に \fauxsc{E-StageBeta}基が出現する場合は,
同値は成立しないことがわかる.


\begin{align}
  \mynext{\mylam{x}{\INT}{x} \mysp \myprev{\mynext{3}}} &\equiv \mynext{\mylam{x}{\INT}{x} \mysp 3} \label{ex_03}\\
  \mynext{\mynext{\mylam{x}{\INT}{x} \mysp \myprev{\mynext{3}}}} &\not\equiv \mynext{\mynext{\mylam{x}{\INT}{x} \mysp 3}} \label{ex_04}
\end{align}

% 同値規則が許される条件
また, \fauxsc{Q-Beta} の適用条件は, インデックス$m$ が, $m = 0$ を満たしている場合のみ, 
すなわち, \mbeta-同値な項が, プログラムコードでない場合に限り, この規則が使用できることがわかる.

% \begin{fig}{\Cref{ex_04}が成立しないことのイメージ}
%   \begin{scprooftree}{0.7}
%     \AxiomC{$\cdots$}
%     \AxiomC{$2 \nleq 1$}
%     \myplabel{Q-StageBeta}
%     \BinaryInfC{$\bullet \myvdash{2} \myprev{\mynext{3}} \not\equiv_2 3$}
%     \AxiomC{$\cdots$}
%     \myplabel{Q-App}
%     \BinaryInfC{$\bullet \myvdash{2} (\mylam{x}{\Int}{x}) \mysp \myprev{\mynext{3}} \not\equiv_2 (\mylam{x}{\Int}{x}) \mysp 3$}
%     \myplabel{Q-NextIntro}
%     \UnaryInfC{$\bullet \myvdash{1} \mynext{(\mylam{x}{\Int}{x}) \mysp \myprev{\mynext{3}}} \not\equiv_1 \mynext{(\mylam{x}{\Int}{x}) \mysp 3}$}
%     \myplabel{Q-NextIntro}
%     \UnaryInfC{$\bullet \myvdash{0} \mynext{\mynext{(\mylam{x}{\Int}{x}) \mysp \myprev{\mynext{3}}}} \not\equiv_0 \mynext{\mynext{(\mylam{x}{\Int}{x}) \mysp 3}}$}
%   \end{scprooftree}
%   \label{fig_ex04_proof}
% \end{fig}

\begin{fig}{項に関する同値規則}
  \centering
  \footnotesize
  \QAbs \bcpnl
  \QApp \bcpnl
  \QBeta \bcpnl
  \QRefl \quad
  \QSym \bcpnl
  \QTrans \bcpnl
  \QNextIntro \bcpnl
  \QPrevIntro \bcpnl
  \QCircBeta \bcpnl
  \QCircEta
  \label{fig_q}
\end{fig}
\FB

% 構文木の同値はアルファ同値か?
% Q-refl に t1 == t2, Gamma |- t_1 : T の規則に変える

% ここで, \fauxsc{Q-Refl} の規則では, アルファ同値であるような規則に変化させる.


\subsubsection{型, カインドに関する同値}
型とカインドに関する同値規則は, \Cref{fig_tq,fig_kq} に示される.
この体系は依存型を含み, 型やカインドの内部にも項が含まれうるため,
型とカインドに関する同値にも, 項に関する同値と同じように, 整数インデックスに関して拡張する必要がある.

たとえば, 内部に項をもつ依存型同士の同値規則である \fauxsc{QT-App} では,
依存型同士の同値のためには, 内部にある項は, 現在のインデックスのもとで同値である必要がある.

\begin{fig}{カインドに関する同値規則}
  \centering
  \footnotesize
  \QKPi \bcpnl
  \QKRefl \quad
  \QKSym \bcpnl
  \QKTrans 
  \label{fig_kq}
\end{fig}

\begin{fig}{型に関する同値規則}
  \centering
  \footnotesize
  \QTPi \bcpnl
  \QTApp \bcpnl
  \QTRefl \quad
  \QTSym \bcpnl
  \QTTrans \bcpnl
  \QTCircIntro
  \label{fig_tq}
\end{fig}

% \subsection{同値型の追加}\label{subsec_equalitytype}
% ここでは, 同値型の体系への追加について述べる. 
% 同値型は一般的な形をしており, Martin-Löf によって提案された形 \cite{Lof1984} をほとんどそのまま使用している.
% % 同値型の規則に関する説明
% 同値型に関する規則は, \Cref{fig_typing} に示される導入規則 \fauxsc{Eq-Intro} と 除去規則 \fauxsc{Eq-Elim} からなる.
% \fauxsc{T-EqIntro}は, 任意の項について, 反射律が成立していることを示している.
% \fauxsc{T-EqElim}は, 除去規則であり, 2つの同じ型$T$をもつ項$a, b$ と, その2つの項に関する同値型を持つ項があった場合, 
% 型$T$を持つ変数$x$が存在する環境において, 型$C(x, x, id(x))$ を持つ項$t$が存在するなら, 
% 型$C(a, b, \myid{a, b})$ を持つ項を導くことができることを示している.

% % 同値型の推移律の証明
% この2つの規則のみで. 同値型は反射, 対称, 推移律を満たしていることが確認できる. ここでは, 反射, 対称律は容易に確認できるため,
% 推移律についてのみ示す.

% \Cref{fig_proof_equality_transitive} において, $z_1\COL \myeq{T}{a}{b}$ と $z_2\COL \myeq{T}{b}{c}$ があったとき,\\
% ${\Gamma \myvdash{n} (\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}) z_2 \COL \myeq{T}{a}{c}}$ が導出できることを示している.

% \begin{fig}{同値型における推移律の証明}
%   \begin{scprooftree}{0.8}
%       \AxiomC{$\Gamma \myvdash{n} a\COL T$}
%       \AxiomC{$\Gamma \myvdash{n} b\COL T$}
%       \AxiomC{$\Gamma \myvdash{n} z_1\COL \myeq{T}{a}{b}$}
%       \noLine
%       \TrinaryInfC{$\Gamma, x\mysncln{n}T, y\mysncln{n}T, p\mysncln{n}\myeq{T}{x}{y} \myvdash{n} \myeq{T}{y}{u} \rightarrow \myeq{T}{x}{u} \DCOL *$}
%       \noLine
%       \UnaryInfC{$\Gamma, x\COL T \myvdash{n} \mylam{m}{\myeq{T}{x}{c}}{m}\COL \myeq{T}{x}{c} \rightarrow \myeq{T}{x}{c}$}
%       \singleLine
%       \myplabel{Eq-Elim}
%       \UnaryInfC{$\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}\COL \myeq{T}{b}{c} \rightarrow \myeq{T}{a}{c}$}
%       \AxiomC{$\Gamma \myvdash{n} z_2\COL \myeq{T}{b}{c}$}
%       \myplabel{T-App}
%       \BinaryInfC{$\Gamma \myvdash{n} (\myidpeel{z_1}{x}{\mylam{m}{\myeq{T}{x}{c}}{m}}) z_2 \COL \myeq{T}{a}{c}$}
%   \end{scprooftree}
%   \label{fig_proof_equality_transitive}
% \end{fig}

% % 同値から同値型の証明
% また, 同値型は体系の同値性から導き出すことができる.
% \Cref{fig_equality_equiv} は, ともに型$T$を持つ項 $t_1$ と$t_2$ と, ${\Gamma \myvdash{n} t_1 \myequiv{m} t_2}$
% から, 型 $\myeq{T}{t_1}{t_2}$ となる項を導く例を示している.

% \begin{figure}[htbp]
%   \begin{scprooftree}{0.7}
%     \AxiomC{$\Gamma \vdash t_1 \COL T$}
%     \myplabel{Eq-Intro}
%     \UnaryInfC{$\Gamma \vdash id(t_1) \COL \myeq{T}{t_1}{t_2}(t_1, t_1)$}
%     \AxiomC{$\Gamma \vdash Eq_T t_1 \DCOL \Pi y\COL T. *$}
%     \myplabel{QT-Refl}
%     \UnaryInfC{$\Gamma \vdash Eq_T t_1 \equiv Eq_T t_1 \DCOL \Pi y\COL T. *$}
%     \AxiomC{$\Gamma \vdash t_1 \equiv t_2$}
%     \myplabel{QT-App}
%     \BinaryInfC{$\Gamma \vdash Eq_T(t_1, t_1) \equiv \myeq{T}{t_1}{t_2}$}
%     \myplabel{T-Conv}
%     \BinaryInfC{$\Gamma \vdash id(t_1) \COL \myeq{T}{t_1}{t_2}$}
%   \end{scprooftree}
%   \caption{同値性から対応する同値型の導出}
%   \label{fig_equality_equiv}
% \end{figure}


% TODO
% \subsection{\lamlfcirc における表現の例}

% next section: ./property.tex
