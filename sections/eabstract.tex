
% == background == %
% multi-stage calculus
\emph{Multi-stage Computation} introduces an idea of stages to computation, which enables 
manipulation of program code as values.
Davies introduced \lamcirc, which included an operator \tnext,
which takes a term and generates a value that represents code for the term,
and an operator \tprev, which takes a code value and converts it to terms.
One of the key features of this system is embedding; one can embed a code in an another code by
applying \tprev{} to the code values we want to embed.
By using these features, \lamcirc can model computation that invokes run-time code generation and evaluation 

% what the type system guarantees
\lamcirc designates a type $\bigcirc T$ for a type $T$.
A value has type $\bigcirc T$ if it is code that produces a value of type $T$ when it is given to \tprev. 
This type system guarantees that no error occurs during generation and evaluation of code at run-time.

% == target == %
We aim at extending \lamcirc so that it can verify more properties.
To this end, we introduce dependent types and equality types to \lamcirc.

% dependent types
% \emph{Dependent types} are types that contains terms. 
\emph{Dependent types} are types that includes terms. 
By using dependent types, one can detect potential runtime errors that cannot be detected by usual type systems.
For example, one can design a dependent type system that guarantees the consistency in matrix multiplication.

% equality types
Martin-Löf introduced equality types. An equality type is an instance of dependent types that includes two terms,
asserting these terms are equal.
Typing rules for equality types are as generic as it can be introduced to any type system
with one introduction rule and one elimination rule if it is equipped with dependent types.

% research method
In this thesis, we extend \lamcirc with dependent types á la \lamlf by Harper et al. and equality types.
Kawata has already proposed \lammd, which extends \lamcirc with CSP and \lamlf;
our type system can be understood as the extension of \lamcirc without CSP
and with equality types.

% reduction rules and stages
The reductions in our system include \mbeta-reduction, reduction on stages, and reduction on equality typed values.
However, we would not like to perform reductions inside code, except for reductions on stages.
Yuse and Igarashi have proposed a method to limit appropriate reductions on terms. They extend reductions relation with
index numbers, that represents how deep the current term is nested under \tnext{} and \tprev.
We also follow their method.

% equality between codes
Also, when comparing equivalence between code, 
we do not want to judge equivalence based on normal equivalence rules such as \mbeta-reduction,
because only stage reduction is allowed inside code. Instead, we want to judge equivalence based on
the corresponding equivalence rules allowed.
For enabling this kind of definition, we expanded the definition of equivalence by adding an index number, 
just as we did in defining reduction.
By limiting the available equivalence rules with this index, 
we make it possible to perform reduction as intended.

% what we have proved
Furthermore, to prove the safety of our proposed system, 
we prove preservation, stating that a type of a term will not change on 1-step reduction,
and also progress, stating that either a well-typed term is a value, or there exists a step of reduction.   
We also prove strong normalization, stating that a well-typed term will not have an infinite sequence of reduction steps,
and confluence of terms under reduction, which shows that there can be multiple reduction paths that yield the same result.
Finally, we introduce algorithmic typing to type terms decidably,
and prove that algorithmic typing is sound and complete with regards to the normal typing rules.

% Future Work
In this research, we have not been able to state what kind of logical system corresponds to 
the type system we have introduced. We know that lambda calculus with dependent types corresponds to
the intuitionistic propositional logic, but it is left for future work of how the logic will extend with
multi-stage computation and equality types.
